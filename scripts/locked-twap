import Web3 from 'web3'
import cliProgress from 'cli-progress'
import dotenv from 'dotenv'
import BN from 'bn.js'
import fs from 'fs'
dotenv.config()

import IdeaTokenExchangeABI from './abis/ideaTokenExchange.json'
import IdeaTokenFactoryABI from './abis/ideaTokenFactory.json'
import IdeaTokenVaultABI from './abis/ideaTokenVault.json'
import ERC20ABI from './abis/erc20.json'

type Config = {
  web3: Web3
  exchangeAddress: string
  factoryAddress: string
  vaultAddress: string
  startBlock: number
  endBlock: number
  isL1: boolean
}

const l1Config: Config = {
  web3: new Web3(process.env.RPC_MAINNET_L1!),
  exchangeAddress: '0xBe7e6a7cD3BEBC1776e64E988bd1518AA3Ad29A4',
  factoryAddress: '0x4bC73348B49f8794FB8b4bDee17B1825e5805DBc',
  vaultAddress: '0xE4f2a4Df3722bE05AbcD49AB734D303b2bBBcD65',
  startBlock: 11830875,
  endBlock: 13572493,
  isL1: true,
}

const l2Config: Config = {
  web3: new Web3(process.env.RPC_MAINNET_L2!),
  exchangeAddress: '0x15ae05599809AF9D1A04C10beF217bc04060dD81',
  factoryAddress: '0xE490A4517F1e8A1551ECb03aF5eB116C6Bbd450b',
  vaultAddress: '0xeC4E1A014fAf0D966332E62970CD7c6553671d76',
  startBlock: 1746173,
  endBlock: 2895118,
  isL1: false,
}


type UserStats = {
  points: Number
  payout: BN
  hasBoughtOnL1: boolean
  hasBoughtOnL2: boolean
  hasListedOnL1: boolean
  hasListedOnL2: boolean
  hasLockedOnL1: boolean
  hasLockedOnL2: boolean
  hasVerifiedOnL1: boolean
  hasVerifiedOnL2: boolean
}

type LockInfo = {
  ideaToken: string,
  owner: string,
  lockedAmount: BN,
  lockedUntil: number,
  LockDuration: number,
}


function initializeNewUserIfNotExists(user: string) {
  if (userStats[user] !== undefined) {
    return
  }

  userStats[user] = {
    points: 0,
    payout: new BN('0'),
    hasBoughtOnL1: false,
    hasBoughtOnL2: false,
    hasListedOnL1: false,
    hasListedOnL2: false,
    hasLockedOnL1: false,
    hasLockedOnL2: false,
    hasVerifiedOnL1: false,
    hasVerifiedOnL2: false,
  }
}

const userStats: { [address: string]: UserStats } = {}

const TOTAL_PAYOUT = new BN('5000000').mul(new BN('10').pow(new BN('18')))
const POINTS_FOR_BUYING = 1
const POINTS_FOR_LISTING = 1
const POINTS_FOR_LOCKING = 2
const POINTS_FOR_VERIFING = 3
const L1_MULTIPLIER = 2
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'

let lastBlockCHecked = l2Config.startBlock
let tokenList = []
let lockedEventList = []
let d = {}
d["d"] = 4
d["tokens"] = ["x", "y", "z"]

async function main() {
  // const lastBlockCHecked = js read file dict["lastBlockCHecked"]
  // const lockedTokenList = js read fine dict["lockedTokenList"]
  // creat a new dict with new values at respective places and rewrite file w new dict
  
  // run script initaially just to get L1 token addresses on the first day. then remove from here
  await runL1(l1Config)
  await run(l2Config)

  const totalPoints = calculatePointScores()
  const totalPayouts = calculatePayouts(totalPoints)
  writeResult()
  console.log(
    `\nFound ${
      Object.keys(userStats).length
    } users with ${totalPoints} total points and ${totalPayouts.toString()} payouts.`
  )
}


function writeResult() {
  const result: { [address: string]: string } = {}
  for (const user in userStats) {
    result[user] = userStats[user].payout.toString()
  }
  fs.writeFileSync('result.json', JSON.stringify(result, null, 2))
}

function calculatePayouts(totalPoints: number): BN {
  let totalPayouts = new BN('0')
  const payoutPerPoint = TOTAL_PAYOUT.div(new BN(totalPoints))
  Object.keys(userStats).forEach((user) => {
    const stats = userStats[user]
    const payout = payoutPerPoint.mul(new BN(stats.points.toString()))
    stats.payout = payout
    userStats[user] = stats
    totalPayouts = totalPayouts.add(payout)
  })

  return totalPayouts
}

function calculatePointScores(): number {
  let total = 0
  Object.keys(userStats).forEach((user) => {
    const stats = userStats[user]

    let points = 0
    points += Number(stats.hasBoughtOnL1) * POINTS_FOR_BUYING * L1_MULTIPLIER
    if (!stats.hasBoughtOnL1) points += Number(stats.hasBoughtOnL2) * POINTS_FOR_BUYING
    points += Number(stats.hasListedOnL1) * POINTS_FOR_LISTING * L1_MULTIPLIER

    total += points
    stats.points = points
    userStats[user] = stats
  })

  return total
}

async function run(config: Config) {
  const { web3, exchangeAddress, factoryAddress, vaultAddress, startBlock, endBlock, isL1 } = config
  await dailyPrices(web3, exchangeAddress, factoryAddress, vaultAddress, startBlock, endBlock, isL1)
  await parseBuys(web3, exchangeAddress, startBlock, endBlock, isL1)
  await parseLocks(web3, vaultAddress, startBlock, endBlock, isL1)
}

async function parseBuys(web3: Web3, exchangeAddress: string, startBlock: number, endBlock: number, isL1: boolean) {
  // Fetch all InvestedState events
  const exchange = new web3.eth.Contract(IdeaTokenExchangeABI as any, exchangeAddress)
  const investedStateEvents = await fetchPastEvents(exchange, 'InvestedState', startBlock, endBlock, true)

  // Since we cannot tell from the InvestedState event alone whether the operation was a buy or sell,
  // we check the same tx for an IdeaToken transfer from the zero address to the user.
  console.log(`\nParsing ${investedStateEvents.length} InvestedState events`)
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)
  bar.start(investedStateEvents.length, 0)
  for (const investedStateEvent of investedStateEvents) {
    const tx = investedStateEvent.transactionHash
    const txReceipt = await web3.eth.getTransactionReceipt(tx)
    const user = web3.utils.toChecksumAddress(txReceipt.from)
    const block = txReceipt.blockNumber

    // Get all of this tokens' transfer events in the same block as the InvestedState event
    const tokenAddress = investedStateEvent.returnValues.ideaToken
    const token = new web3.eth.Contract(ERC20ABI as any, tokenAddress)
    let transferEvents = await fetchPastEvents(token, 'Transfer', block, block, false)

    // Filter out the transfer events that are not from the zero address and not in the correct tx
    transferEvents = transferEvents.filter((event) => {
      return event.transactionHash === tx && event.returnValues.from === ZERO_ADDRESS
    })

    if (transferEvents.length > 0) {
      // This is a buy.
      // Store it in the user's stats.
      initializeNewUserIfNotExists(user)
      if (isL1) {
        userStats[user].hasBoughtOnL1 = true
      } else {
        userStats[user].hasBoughtOnL2 = true
      }
    }

    bar.increment()
  }

  bar.stop()
}


async function parseLocks(web3: Web3, vaultAddress: string, startBlock: number, endBlock: number) {
  // Fetch all Locked events
  const vault = new web3.eth.Contract(IdeaTokenVaultABI as any, vaultAddress)
  const lockedEvents = await fetchPastEvents(vault, 'Locked', startBlock, endBlock, true)
  
  // Iterate over events to fetch user addresses
  console.log(`\nParsing ${lockedEvents.length} Locked events`)
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)
  bar.start(lockedEvents.length, 0)
  for (const lockedEvent of lockedEvents) {
    const tx = lockedEvent.transactionHash
    const txReceipt = await web3.eth.getTransactionReceipt(tx)
    const user = web3.utils.toChecksumAddress(txReceipt.from)
    
    tokenList.push(lockedEvent.returnValue.ideaToken)
    // read store a lock event struct that writes the details of the lock for later use
    lockedEventList.push({ideaToken: lockedEvent.returnValue.ideaToken, user: lockedEventS, block: lockedEvent.blockNumber})
    bar.increment()
  }
  bar.stop()

  return tokenList
}

async function dailyPrices(web3: Web3, exchangeAddress: string,  vaultAddress: string, startBlock: number, endBlock: number) {
  // Fetch all InvestedState events
  const exchange = new web3.eth.Contract(IdeaTokenExchangeABI as any, exchangeAddress)
  let existingTokens = [] //read from file
  let newTokens = await parseLocks(web3, vaultAddress, startBlock, endBlock)
  let tokens = Array.from(new Set(newTokens.concat(existingTokens)))

  console.log(`\nParsing ${tokens.length} Token list`)
  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)
  bar.start(tokens.length, 0)

  let priceDict = {}
  for (const token of tokens) {
    // get token price 
    // write dict of token address to price for that specific date
    priceDict[token] = await getTokenPrice(web3, token)

    bar.increment()
  }
  // write priceDict to file for that date
  bar.stop()
  //write new file with new tokens and endblock
}

async function fetchPastEvents(
  contract: any,
  eventName: string,
  startBlock: number,
  endBlock: number,
  withDisplay: boolean
): Promise<any[]> {
  withDisplay && console.log(`\nFetching ${eventName} events from ${startBlock} to ${endBlock}`)

  const originalStepSize = 100_000
  let stepSize = originalStepSize
  let currentBlock = startBlock
  let allEvents: any[] = []

  const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic)
  withDisplay && bar.start(endBlock - startBlock + 1, 0)

  while (currentBlock <= endBlock) {
    let iterationEndBlock = currentBlock + stepSize
    if (iterationEndBlock > endBlock) {
      iterationEndBlock = endBlock
    }

    let events
    try {
      events = await contract.getPastEvents(eventName, { fromBlock: currentBlock, toBlock: iterationEndBlock })
    } catch (ex) {
      // There are too many events in this range to fetch in one go.
      // Decrease the step size and try again.
      stepSize = Math.floor(stepSize / 2)
      continue
    }

    withDisplay && bar.increment(iterationEndBlock - currentBlock)
    allEvents = allEvents.concat(events)
    currentBlock = iterationEndBlock + 1
    stepSize = originalStepSize
  }

  withDisplay && bar.update(endBlock - startBlock + 1)
  withDisplay && bar.stop()
  withDisplay && console.log(`Fetched ${allEvents.length} ${eventName} events`)
  return allEvents
}

main()
